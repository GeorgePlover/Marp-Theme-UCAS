---
marp: true
theme: Simple
paginate: true
---

<style scoped>
    section {
  text-align: center;
    }
</style>

<!--
_backgroundImage: url("./images/bg1.jpg")
_paginate: false 
-->

![img w:400px h:80px](./images/white.png)
# 数据结构
## 第2次机考讲评


**2023-9-20**


---

<!--_header: 考试技巧 -->

### 1000ms 一般情况下各数据规模可允许的算法时间复杂度

* $n=10^7 \implies O(n)$
* $n=10^6 \implies O(n\log n)$
* $n=10^5 \implies O(n\log^2) \ or\ O(n\sqrt n)$
* $n=5000 \implies O(n^2)$
* $n=1000 \implies O(n^2\log n)$
* $n=400 \implies O(n^3)$
* $n=24 \implies O(2^{n})$
* $n=10 \implies O(n!)$ 

实际运行速度也和常数强相关，多练习有助于感受算法时间复杂度能否通过。

---

<!--_header: A. 最大子段和 -->

### 题意
* #### 输入整数序列 $a_1,a_2\cdots a_n$ ，求一个最大子段 $[L,R]$ ，使得 $\sum_{i=L}^R a_i$ 尽可能大



### 算法0

* #### 利用前缀和可以 $O(1)$ 查询任何一个区间的和；但是枚举区间仍然需要 $O(n^2)$ 复杂度。
### 算法1 基于前缀和
* #### 考虑 $\sum_{i=L}^R a_i = sum_{R}-sum_{L-1}$ ；枚举区间右端点 $R$，在已知右端点的情况下，找到一个 $sum_{L-1}$ 尽可能小的左端点 $L$，则可以找出固定右端点情况下的最优区间和。
* #### 转化为快速求解 $\min\{sum_{L-1}\big| 1\le L\le R \}$，这其实是一个前缀最小值，可以 $O(n)$ 预处理，$O(1)$ 查询。总复杂度 $O(n)$。

---

<!--_header: A. 最大子段和 -->

### 算法2 贪心
* #### 贪心向右扩展区间，把下一个值囊括在区间范围中，并维护区间和
* #### 如果区间和$\ge 0$，则记录区间和，继续算法；否则舍弃当前区间，将其清空
* #### 取所有记录的区间和的最大值，并注意特判全部为负数的情况。 

### 注意
* #### 注意计算答案的值域范围，例如这道题答案的极限范围为 $10^5\times 10^9 =10^{14}$
* #### 这会超过 int 范围。


---

<!--_header: B. 最小乘积 -->
### 题意

* #### 给定 $a,b,x,y,n$ 每次操作可以让 $a,b$ 中的一个减少1，或者都不变，但是最后要满足 $a\ge x,b\ge y$ ，求 $a\cdot b$ 的最小值。

### 做法

* #### $n$ 次机会要尽可能用掉。已知两数之和确定时，相差越大，积越小，所以最后要使得两数相差尽可能大。

* #### 考虑所有情况后取最优解即可：
  * 先尽可能减 $a$ 然后减 $b$ ；
  * 先尽可能减 $b$ 然后减 $a$ 。

---

<!--_header: C. 打牌 -->

### 题意

* #### $n$ 个人平分 $n\times m$ 张牌，每张牌上的整数不同且都在 $1 到 nm$ 之间。给定你的牌，问你最坏情况下能赢几轮。 

### 做法

* #### 最坏情况下，假设有个人拿了除了你的牌之外尽可能大的 $m$ 张牌，然后每次你打出牌时，他总是打出能赢你的牌中最小的牌。如果他没有能赢你的牌，就打出他最小的牌应付。

* #### 模拟即可，复杂度可以做到 $O(nm)$ 


---

<!--_header: D.看番 -->
### 题意
* #### 有 $n$ 个互不相交的精彩视频区间要看，对于不精彩的部分可以以 $x$ 时间为最小粒度向前跳过，跳过不需要花时间。问至少要用多少时间看完所有区间。

### 做法
* #### 直接求和，对于精彩区间，必须完整观看，直接加上去；对于非精彩区间，观看其长度 $len \bmod x$ 的时间。复杂度 $O(n)$ 

---

<!--_header: E. 高精度乘法 -->

### 题意
* #### 大数乘法，数的长度不超过 $5000$

### 做法
* #### 模拟乘法竖式。第一个数的第 $i$ 位 $a_i$ 实际表示了 $a_i\times 2^i$，第二个数的第 $j$ 位 $b_i$ 同理，那么两位相乘将给结果的第 $i+j$ 位带来 $a_i\cdot b_j$ 的贡献。

* #### 先统计任意两位相乘带来的贡献，再扫描一遍处理进位。

---

<!--_header: 机考.123=6 -->
### 题意
* #### 询问一个排列 $p_1,p_2\cdots p_n$ 中有多少个顺序四元组 $(a,b,c,d)$ 满足 $a<b<c<d,p_a<p_b<p_c<p_d$并且 $p_a\cdot p_b\cdot p_c=p_d$。$n\le 10^6$

### 做法
* #### 枚举，但是要做优化，否则就是 $O(n^4)$ 不可接受。首先我们预处理出 $loc_i$ 数组，表示数字 $i$ 的出现位置。
* #### 第一层循环枚举 $p_a\in [1,100]$，第二层循环枚举 $p_b\in [p_a+1,1000]$，第三层枚举 $p_c\in [p_b+1,n/(p_ap_b)]$ , $p_d$ 不用枚举，直接取 $p_d = p_ap_bp_c$ ，然后验证四个数的 $loc$ 是否递增。
* #### $loc$ 递增可以在每一层循环都检验。极限数据情况下，四元组数量是 $10^7$ 级别，可以通过。


---

<!--_header: 机考.拍照 -->
### 题意
* #### $n$ 个同学按照给定顺序逐个加入队伍进行拍照。每增加一个人，拍一次照，拍照时同学们按照学号自动排序。拍照的美观度是相邻同学身高差的平方和。 要求输出每张照片的美观度。人数，身高均不超过 $10^6$

### 做法

* #### 反过来，先有 $n$ 个同学按照身高排序，每次指定一个同学离开。假设离开的同学学号是 $x$ ，他左边是 $l_x$ 号同学，右边是 $r_x$ 号同学。他离开时，美观度的变化为 $-dis^2(x,l_x)-dis^2(x,r_x)+dis^2(l_x,r_x)$，其中 $dis(i,j)$ 表示学号为 $i,j$ 的同学的身高差。

* #### 用链表维护同学的离开即可，每次操作 $O(1)$ ，总复杂度 $O(n)$。

---

<!--_header: 代码问题 -->

### 变长数组的声明

#### 不被C++支持：（部分编译器支持了，但不代表总是能使用）
```c++
int main(){
  int n;
  cin>>n;
  int a[n];
}
```
#### 请使用全局变量或者vector
```c++
#define MAXN 100000
int a[MAXN];
int main(){

}
```
```c++
int main(){
  int n;
  cin>>n;
  vector<int> a(n,0);
}
```

---

<!--_header: 代码问题 -->
### 类型转换产生的错误
* #### unsigned 溢出
```c++
for (int i = 0;i <= num.size() - 1;i++);//size为0的时候并不会立即终止循环
```

* #### int 溢出
```c++
int a=1000000000,b=1000000000;
long long mul = a*b;//得不到正确的值
```





 