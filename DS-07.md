---
marp: true
theme: Simple
paginate: true
---

<style scoped>
    section {
  text-align: center;
    }
</style>

<!--
_backgroundImage: url("./images/bg1.jpg")
_paginate: false 
-->

![img w:400px h:80px](./images/white.png)
# 数据结构
## 第7次机考讲评


**2023-11-01**

---

<!--_header: A. 树的重心 -->

### 题意
* #### 课堂PPT中的例题，求树的重心，即满足以该结点为根时，所有子结点的子树的大小均不超过 $n/2$ 。

### 做法

* #### 求解每个结点为根时，各子结点的子树的大小即可。不妨先以 $1$ 为根，通过遍历树，求出 $size(x),1\le x\le n$ （表示从 $x$ 向下的子树结点个数）。

* #### 按照定义计算机即可，考虑到结点 $x$ 向上产生的子节点子树大小是 $n-size(x)$ 即可。


复杂度 $O(n)$ 。

---

<!--_header: B. 树德遍历 -->

### 题意
* #### 给出一棵 $n$ 个结点的树，可选择任何一个结点出发，要求遍历每个结点至少一次，问最少经过的边数。

### 做法
* #### 找到树上最长链的长度 $d$ ，然后 $2(n-1)-d$ 就是答案。因为起点到终点之间的边只用经过一次。

* #### 树上最长链的长度即树的直径，有至少两种经典解法。

* #### 参考：[https://oi-wiki.org/graph/tree-diameter/](https://oi-wiki.org/graph/tree-diameter/)

---

<!--_header: C. 有多远？ -->
### 题意
* #### 给出一棵 $n$ 个结点的树，树边有边权值，有 $m$ 次询问，每次询问两个树上结点之间的距离。

### 做法1：

* #### 每次询问直接以起点为根做一次搜索，处理出到达终点的距离。

* #### 复杂度 $O(nm)$

### 做法2：LCA

* #### 首先，不妨以 $1$ 为根，进行一边树的遍历，求解每个结点到根节点的距离 $d(x),(1\le x\le n)$ 。然后对于每组询问 $x,y$ ，求出最近公共祖先 $z=lca(x,y)$ 。答案为 $d(x)+d(y)-2d(z)$。

* #### 以朴素的倍增lca做法为例，复杂度为 $O((n+m)\log n)$ 。


---

<!--_header: D. Phone List -->
### 题意
* #### 给定 $n$ 个长度不超过 $10$ 的数字串，问其中是否存在两个数字串 $S,T$，使得 $S$ 是 $T$ 的前缀，多组数据。

### 做法1：

* #### 使用字典树（Trie）。将所有字符串插入字典树，并在结束位置做记录。之后查验每个字符串，若其结束位置在Trie上还有子节点或者是该位置有多个记录，则说明该串是某个串的前缀。复杂度 $O(n)$

### 做法2：

* #### 用string存储每个字符串，然后排序。排序后只需要检验相邻两个字符串 $S_i,S_{i+1}$，是否 $S_i$ 是 $S_{i+1}$ 的前缀即可。复杂度 $O(n\log n)$


---

<!--_header: E. 约克镇之战 -->
### 题意

* #### 给出一个二维平面矩形，中间有若干圆形区域不能踏足，问是否存在一条路线从矩形的左下角到达右上角。



### 做法：

* #### 把左边界和上边界抽象为点 $S$ ，右边界和下边界抽象为点 $T$ 。把每个圆形抽象为点 $1,2,\cdots n$ 。如果上述两个图形有交集，就在他们抽象出的点之间建一条边，得到一张图。这样，原问题等价于判断 $S,T$ 是否连通，如果连通则输出 NO，反之输出 YES 。复杂度 $O(n^2)$ 。 

---

<!--_header: . 米奇妙妙树 II -->

### 题意

* #### 给出一棵 $n$ 个结点的树，有 $m$ 次染色，每次选中一个结点 $x$ ，把 $x$ 到根的结点染成颜色 $k$ 。询问最后每个点的颜色。 

### 做法

* #### 每个结点的最终颜色，只取决于子树中结点最后一次染色的颜色，因此类似于上周的米奇妙妙树I，把每个结点最后染色的操作序号记录。

* #### 最后对于每个结点，只需要求子树最大值即可。（定义 $f(x)$ 表示 $x$ 为根的子树中的最大值，有递推式 $f(x) = \max\{c_x,f(v) \big| v\in son(x) \}$。

---

<!--_header: . 本质不同子串计数 -->

### 题意

* #### 给出一个字符串，计算其本质不同子串的数量。

### 做法

* #### 维护一个字典树（Trie），将该字符串的每个后缀加入字典树，最后输出字典树的结点个数即可。复杂度 $O(n^2)$ 。

* #### 字典树实现，参考资料：[https://oi-wiki.org/string/trie/](https://oi-wiki.org/string/trie/)

---
<!--_header: . 一些提醒 -->

* #### 注意数据范围和读写效率，1e6级别的数据，使用cin需要关闭流同步，并且不与其他输入输出方式混用。

* #### 递归函数传参和传引用的区别。








 