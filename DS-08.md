---
marp: true
theme: Simple
paginate: true
---

<style scoped>
    section {
  text-align: center;
    }
</style>

<!--
_backgroundImage: url("./images/bg1.jpg")
_paginate: false 
-->

![img w:400px h:80px](./images/white.png)
# 数据结构
## 第8次机考讲评


**2023-11-08**

---

<!--_header: A. 石子合并 -->

### 题意
* #### 有 $n$ 堆石子，第 $i$ 堆石子有 $a_i$ 个。每次合并两堆石子的代价是他们的石子个数之和。问把所有石子合并为一堆的最小代价。

### 做法

* #### 经典的哈夫曼树运用。在实现时，每次选择最小的两堆石子合并，得到一堆新的石子，模拟这个过程 $n-1$ 次即可。

* #### 在实现时，可以使用最小堆，或者 `priority_queue` 以及 `set` 。


复杂度 $O(n\log n)$ 。

---

<!--_header: B. 最小的n个和 -->

### 题意
* #### 给出两个长度为 $n$ 的数列 $A,B$ ，从中各选一个数相加，根据选法不同，产生 $n^2$ 个数。询问其中最小的 $n$ 个数。

### 做法
* #### 首先将 $A,B$ 分别从小到大排序。

* #### 注意到所有从 $A$ 中选出 $a_i$ 的方法，一共产生 $n$ 个数，他们是 $a_i+b_1,a_i+b_2\cdots a_i+b_n$ ，此时这些数是单调递增的。考虑 $1\le i\le n$，于是我们可以看做有 $n$ 个单调递增的序列（不必把这个序列存下来）。

---

<!--_header: B. 最小的n个和 -->


* #### 我们先把这 $n$ 个序列的第一个元素（即最小的）放入一个最小堆中，接下来开始模拟：

1. #### 每次从最小堆中取出全局最小的数，输出。然后从最小堆中删除这个数。

2. #### 我们需要知道这个被删除的数是来自哪个序列的，然后我们把这个序列的下一个数又放入最小堆中。

#### 这样，我们始终保证了最小堆中元素是每个序列还未被取走的数中的最小值，那么堆顶就始终是所有还未取走的数中的最小值。模拟 $n$ 步即可。

#### 注意边界情况，当序列取空之后要特判。为了使得堆中元素保留他来自哪个序列的信息，可以使用 `pair<int,int>` 。

复杂度 $O(n\log n)$

---

<!--_header: C. 前缀的TopK -->
### 题意
* #### 给出长度为 $n$ 的数组 $\{a_i\}$ 。考虑其每个长度不少于 $k$ 的前缀，问这些前缀序列中，排名第 $k$ 大的数是多少？

### 做法：

* #### 维护一个最小堆，最小堆用来维护前 $k$ 大的元素。

* #### 每次新加入一个元素 $x$ 时，考察它与最小堆的最小值 $v_{\min}$ 的大小关系：如果 $x\ge v_{\min}$ ，则我们可以把 $x$ 加入最小堆并同时删除 $v_{\min}$ ；否则我们直接忽略 $x$ 。

* #### 这样，最小堆的堆顶始终是目前的第 $k$ 大值。



---

<!--_header: D. 模后和 -->
### 题意
* #### 给定两个序列 $\{a_i\}$ 和 $\{b_i\}$ ，要求给他们随意重排，使得 $\sum_{i=1}^n \bigg( (a_i+b_i) \mod n\big)$ 尽可能大。

### 做法：

* #### 先把两个序列中的值全部模 $n$ ，不影响答案。

* #### 因为两个 $n$ 以内的数相加不会达到 $2n$ ，问题转化为匹配出 $n$ 对数，使得两数之和 $\ge n$ 的对数尽可能少。

* #### 假设完全匹配中，最多可以有 $k$ 对数的和小于 $n$ 那么这 $k$ 对数完全可以分别来自于两个序列中最小的 $k$ 个数。 

* #### 于是我们可以先分别把两个数列排序。然后二分 $k$ 的大小，二分过程中的每一步，贪心检验两数列的前 $k$ 个数能否匹配出 $k$ 对加和小于 $n$ 的匹配。验证方法其实只需要让 $a_1$ 配 $b_k$ ，$a_2$ 配 $b_{k-1}$ …… $a_k$ 配 $b_1$ 即可。

复杂度 $O(n\log n)$。

---

<!--_header: E. 中庸之道 I -->
### 题意

* #### 给出 $n$ 个操作，要么是添加一个数 $x$ ，要么是询问已经添加的数中的中位数。

### 做法：

* #### 记中位数为 $x_m$ 。记已添加的数的个数为 $N$ 。

* #### 维护对顶堆：一个最大堆维护包含 $x_m$ 在内的左侧的数，即最小的 $\lceil \frac{N}{2} \rceil$ 个数；一个最小堆维护剩下的 $\lfloor \frac{N}{2} \rfloor$ 个数。这样，最大堆的堆顶就是每次询问的答案。我们接下来思考每次添加一个数的时候需要做什么。

---

<!--_header: E. 中庸之道 I -->

* #### 添加 $x$ 时：如果最大堆没有元素，就意味着此时是第一次添加，直接把 $x$ 放入最大堆。

  * #### 如果最大堆有元素，其堆顶为 $x_m$ 。比较 $x$ 与 $x_m$。如果 $x\le x_m$ 则把 $x$ 加入到最大堆；否则，加入到最小堆。此操作是为了维护顺序正确。
* #### 插入 $x$ 后，接下来调整堆中元素个数：我们知道最大堆的 size 应该保持 $\lceil \frac{N}{2} \rceil$，因此如果其 size 不足，就把最小堆的最小元素挪过来，如果 size 超出，就把最大堆的最大元素挪进最小堆。

* #### 如果不愿意思考细节，上面的挪动操作可以用`while`做条件。事实上，每次加入新元素后，最多进行一次挪动。

复杂度 $O(n\log n)$


---

<!--_header: . 出成绩 -->

### 题意

* #### 中庸之道改编版：输出排名前 30% 的最低分数；人数较少时特殊处理。 

### 做法

* #### 和中庸之道类似，只是要在最小堆中保持 $\lfloor 0.3N \rfloor$ 个元素。

