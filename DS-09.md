---
marp: true
theme: Simple
paginate: true
---

<style scoped>
    section {
  text-align: center;
    }
</style>

<!--
_backgroundImage: url("./images/bg1.jpg")
_paginate: false 
-->

![img w:400px h:80px](./images/white.png)
# 数据结构
## 第9次机考讲评


**2023-11-15**

---

<!--_header: A. 选课 -->

### 题意
* #### 给出一张有向无环图，没有入度的点是可删除的，每次从没有入度的点中选择编号最大的点删除，直到图空。输出删除序列。

### 做法

* #### 带有优先级的拓扑排序问题。做法一，模拟整个过程：每次访问每个结点，检查其入度，获得入度为零的编号最大的点 $x$，将 $x$ 删除，并更新 $x$ 出边指向的点的入度。需要注意可能存在多重边（同一条边多次出现在输入数据中）。复杂度 $O(n^2)$ 。

* #### 方法二：将入度为零的点放入优先队列中。每次操作时，从优先队列的顶部取出要删除的结点 $x$，删除 $x$ 并更新其出边指向结点的入度。如果有结点入度变为 $0$ 则立即将其放入优先队列。复杂度 $O(m+n\log n)$ 。其中 $m$ 是边的数量。


---

<!--_header: B. 01迷宫 -->

### 题意
* #### 给出一个可以让人上下左右移动的01迷宫。额外限制：如果此刻位于1上，那么下一步只能走到0上；如果此刻正在0上，下一步只能走到1上。

### 做法
* #### 本质是一张 $n^2$ 个结点，$O(n)$ 条边的图（相邻的异色方格之间连边），然后进行图的遍历，来判断能走到多少个结点。一种做法是，对每个结点编号 $num(i,j) = i*(n-1)+j$ ，可以把方格映射到 $[1,n^2]$ 。然后建图解决。复杂度 $O(mn^2)$ 

* #### 注意到，我们可以预处理出每个结点属于哪一个连通块（在遍历图的时候，进行染色即可），并且在遍历完毕一个连通块时，我们可以知道它的结点数量。因此我们可以通过预处理这些信息实现 $O(1)$ 回答询问，复杂度 $O(n^2 + m)$

---

<!--_header: C. 这就是法国 -->

### 题意

* #### 平面图上有 $n$ 个点。第 $i$ 个点的坐标是 $(x_i,y_i)$ 。要求访问每个点至少一次。有两种操作：1. 可以花费 $c_i$ 的代价直接访问点 $i$ ；2. 可以花费 $(k_i+k_j)\times (|x_i-x_j|+|y_i-y_j|)$ 的代价从一个已经访问过的点 $j$ 出发去访问点 $i$ 。在已经访问过一次的点之间移动不需要任何开销。

### 做法

* #### 把 $n$ 个点看做结点，并且抽象一个超级源结点 $S$ ，这样一共 $n+1$ 个结点。接下来，考虑两种边：$i,j(1\le i< j\le n)$ 之间的边，代价即为  $(k_i+k_j)\times (|x_i-x_j|+|y_i-y_j|)$；另一种，$S$ 到 $i(1\le i\le n)$ 的边，代价即为 $c_i$ 。然后对这些边执行最小生成树算法即可。

* #### 使用prim算法，复杂度 $O(n^2)$。

---

<!--_header: D. 最短路 -->
### 题意
* #### 标准的单源最短路问题，使用SPFA算法、Dijkstra算法均可。

---

<!--_header: E. 【模版】floyd -->
### 题意
* #### 多源最短路问题使用 floyd 算法解决。

* #### 注意循环的嵌套次序。

---

<!--_header: . 构造有向无环图 -->
### 题意

* #### 构造一个 $n$ 个结点 $m$ 条有向边的无环图。不允许有多重边。

### 做法：

* #### 对于所有的二元组 $(i,j)$,$1\le i< j\le n$，任选 $m$ 个输出即可。

* #### 因为所有边都是从编号小的结点指向编号大的结点，因此不可能有环。 

---

<!--_header: . 奇怪的最小生成树 -->

* #### 原问题（生成一棵以1为根的树，边的代价为边权乘上两端点size的较小值，要求代价尽可能少）等价于：
  * 求解 $1$ 到所有点的单源最短路 $dis(1),dis(2),\cdots dis(n)$ 之和。答案即为 $\sum_{i=1}^n dis(i)$ 。

* #### 证明：
  * 任何一个原问题：每一条边，其两侧的连通块要么有结点 $1$，要么没有。权值被计算的次数，等于没有结点 $1$ 的那一侧的结点数。这样，其实边的代价之和，就等于树上每个结点到 $1$ 的距离之和。

  * 因此任何一个生成树（原问题，A），在价值上等于一个路径和（新问题，B）。

  * 最短路能求解出路径和（问题B）的最优解，并且这个最优解可以构造出一个最短路径树，得到一棵生成树（问题A），即为最优的生成树。


