---
marp: true
theme: Simple
paginate: true
---

<style scoped>
    section {
  text-align: center;
    }
</style>

<!--
_backgroundImage: url("./images/bg1.jpg")
_paginate: false 
-->

![img w:400px h:80px](./images/white.png)
# 数据结构
## 第4次机考讲评


**2023-10-10**

---

<!--_header: A. 后缀表达式 -->

### 题意
* #### 给出一个后缀表达式，求算式最终的值

### 做法

* #### 后缀表达式的特点在于不需要处理运算符优先级。扫描一遍，遇到数字就把数字入栈，遇到符号就把数字栈的顶端两个值拿来运算即可。用栈模拟，时间复杂度 $O(n)$ 。

---

<!--_header: B. 滑动窗口 -->

### 题意
* #### 经典的滑动窗口问题，给出一个长度为 $n$ 的序列，求解所有长度为 $K$ 的区间最大值之和。

### 做法（单调队列）
* #### 从左到右滑动窗口，维护窗口内的元素。从定义上，需要使窗口内的元素形成单调队列，即队列中的元素按照进队顺序排列，且具有单调性，就本题而言，需要维护从队首到队尾单调递减的单调队列。
* #### 维护单调队列的关键：当新元素 $x$ 入队时，如果 $x$ 大于了当前的队尾元素，此时直接将新元素入队则不能维护单调性；于是应当将队尾元素从队尾删除，直到队列为空或新元素不大于队尾元素。

---

<!--_header: B. 滑动窗口 -->
### 查询最值
* #### 维护队首：检查队首元素是否已经滑出窗口，如果是则将队首元素弹出。此后，队首元素即为窗口中最大值。

* #### 正确性：当新入队的元素 $x$ 大于 $tail$ 时，$tail$ 应当删去，这是因为 $tail$ 一定不可能成为区间最大值了（它比 $x$ 小，而且会比 $x$ 先滑出窗口），所以单调队列是利用及时排除无意义数据来高效维护答案的。

---

<!--_header: C. 四角不同色 -->
### 题意

* #### 构造 $n\times m$ 的 01 矩阵，使得每一个长宽不低于2的子矩阵中，四个角的元素不全相同。如果有解，要求输出字典序最小的答案，否则输出无解。

### 做法
* #### 容易发现当 $n=2$ 或 $m=2$ 时一定有解，而且容易构造。

* #### 当 $n=3$ 时，若要有解，可以粗略判断出 $m\le 8$ 是必要的，否则将会出现两列完全相同，这时必然会有四角同色的子矩阵。

* #### 据此可以预估出当 $\min(n,m)>2$ 时，若要有解，则 $\max(n,m)$ 不会很大。据此可以进行搜索算法，构造出字典序最小方案。可以即时搜索，也可以跑出答案后编写在代码里直接输出。时间复杂度 $O(2^{24})\text{ 或 }O(1)$ 

* #### 最终结论：在题目条件下，$\min(n,m)\le 4$ 且 $\max(n,m)\le 6$ 时一定有解，否则无解。

---

<!--_header: C. 四角不同色 -->
### 状压搜索技巧

* #### 每次递归搜索确认一个位置是0还是1可能会带来较大的常数开销，且不利于在中途去除不合法的解。可以考虑每层递归搜一行的状态，用 $[0,2^{m}-1]$ 这些整数来表示所有可能的 $m$ 位二进制串即可。

* #### 验证四角矩阵，可以直接枚举两行的二进制数，进行位运算快速验证。（例如，与运算后检查1的个数/或运算后检查0的个数，均不超过1才可）

---

<!--_header: D. 括号序列III -->

### 题意

* #### 给出一个4类括号的序列，左括号之间可以互相变换，右括号之间也可以互相变换，问能否变换得到匹配的括号序列，并输出最少变换次数。

### 做法

* #### 括号序列如果能匹配，那么左右括号之间的对应关系是唯一的，因此只需要做一遍左右括号匹配，然后统计每一对左右括号中，种类不同的对数有多少即可。
* #### 用栈模拟即可，来一个左括号则入栈，来一个右括号则让栈顶左括号与之匹配并弹出，如果出现左括号耗尽而无法匹配或者栈最终非空，则无解。时间复杂度 $O(n)$ 。



---

<!--_header: E.快速幂 -->
### 题意
* #### 经典快速幂问题，询问 $a^b$ 对 $c$ 取模的结果。

### 做法
* #### 将 $b$ 进行二进制拆位，我们只需要处理出 $a,a^2,a^4,a^8,\cdots a^{2^{\lfloor \log_2 b\rfloor}}$ 即可，然后根据 $b$ 的二进制位为1的位，把对应的 $a$ 的“2的整数次幂”的幂相乘即可，复杂度 $O(\log b)$。

```cpp
int qpow(int a,int b,int c){
    int ans = 1;
    while(b){
        if(b&1)ans=ans*1ll*a%c;
        a=a*1ll*a%c;
        b>>=1;
    }
    return ans;
}

```

---

<!--_header: E.快速幂 -->

### 不正确的写法：

```cpp
long long quick_mod(int n, int m) {
    if (m == 0)  
        return 1;
    if (m == 1)
        return n;
    if (m % 2 == 0)
        return (quick_mod(n, m / 2) * quick_mod(n, m / 2)) % MOD;
    if (m % 2 == 1)
        return (quick_mod(n, m / 2) * quick_mod(n, m / 2 + 1)) % MOD;
    return 0;
}
```


---

<!--_header: F. 重复字符串I -->

### 题意
* #### 给出一个长度为 $n$ 的字符串 $s$ ，要在其中找到一个子串 $t$ 在里面非重叠的出现至少两次，找出最长的 $t$ 的长度。

### 做法
* #### 考虑两个相同子串的出现位置。
* #### 定义 $f(i,j)$ 表示从 $s[i]$ 和 $s[j]$ 分别作为开头能匹配的最大长度。当 `s[i]!=s[j]` 时，$f(i,j)=0$ ；否则 $f(i,j) = f(i+1,j+1)+1$。需要注意，因为不能重叠，所以 $f(i,j)$ 转移的时候不应该超过 $|i-j|$ 。

复杂度 $O(n^2)$

---
<!--_header: G. 争夺土地 -->

### 题意

* #### 给出一个 $n\times m$ 的矩阵，矩阵元素仅含有 $0,1$ 两种颜色。可以任选一些行，把这些行的元素颜色取反。问操作后，矩阵中最大的纯色子方阵的面积。

### 做法 二分答案+滑动窗口

* #### 首先关注到，对每一行来说，重要的不是每个位置是什么颜色，因为颜色可以自由翻转，而重要的是同色段。

* #### 预处理出 $d_{i,j}$ 表示每个位置向左延申的同色块的长度，这可以 $O(n^2)$ 递推出来。

* #### 我们先关注如何判断边长为 $x$ 的子方阵有没有可能产生。假设 $(i,j)$ 是这个子方阵的右下角，那么必须满足：$\min\bigg\{d_{u,j} \bigg| i-x+1 \le u\le i \bigg\} \ge x$

* #### 求解固定窗口中的最值，用滑动窗口模型，复杂度 $O(nm)$ 。结合二分答案，即可解决原问题，复杂度 $O(nm\log n)$

---

<!--_header: 机考. 螺旋矩阵 -->

### 题意：

* #### 输出一个 $n\times m$ 的螺旋矩阵

### 做法

* #### 模拟即可

一个技巧是，提前定义好方向数组：`dx[4]={0,1,0,-1},dy[4]={1,0,-1,0}`

这样，方向 `Dir = 0` 开始，每次方向转换后 `Dir = (Dir+1)%4`

每次移动可以看作 `x+=dx[Dir],y+=dy[Dir]`

---

<!--_header: 机考. 序列延伸与后缀查询 -->

### 题意：

* #### 实现数据结构，支持序列的尾部插入，以及后缀的最值询问，要求在线解决。

### 做法：单调栈+二分查找

* #### 回顾滑动窗口时我们求解的单调队列，及时把不可能成为答案的数据扔出队列，维护出了具有单调性的队列。

* #### 在这个问题中，我们维护单调栈（单调递减），相当于头部不动的单调队列。注意到，单调栈中的元素，不但大小是具有单调性的，其下标也是具有单调性的。

* #### 查询范围 $[l,end]$ 时，我们在单调栈上二分查找到下标第一个超过 $l-1$ 的位置，对应元素的值就是答案。

* #### 例子，$A=\{5,7,3,5,1,2,3 \}$，则单调栈中的元素为 $\{ 7,5,3\}$ ，对应的下标是 $\{2,4,7\}$ 。如果询问 $\max \{a_3,... a_7\}$ 则会在下标序列中二分查找找到下标 $4$ ，并把 $a_4=5$ 作为答案.

复杂度 $O(n\log n)$

---

<!--_header: 机考. 序列延伸与后缀查询 -->

#### 存在一种类似于ST表思想的做法，时间复杂度也是 $O(n\log n)$ ，且空间复杂度 $O(n)$ 并且常数很小。有部分同学实现了该做法。










 