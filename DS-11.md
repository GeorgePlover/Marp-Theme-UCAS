---
marp: true
theme: Simple
paginate: true
---

<style scoped>
    section {
  text-align: center;
    }
</style>

<!--
_backgroundImage: url("./images/bg1.jpg")
_paginate: false 
-->

![img w:400px h:80px](./images/white.png)
# 数据结构
## 第11次机考讲评


**2023-11-28**

---

<!--_header: A. 五折券 -->

### 题意
* #### 给出 $n$ 个商品，第 $i$ 个商品价格为 $a_i$ 元，给出 $m$ 次操作，每次可以选择一个价格减半下取整。求最后最低的全部价值之和。

### 做法

* #### 贪心的选取价格最大的商品使之价格减半即可，模拟 $m$ 次，可以用优先队列来维护最大价格。每次从优先队列中取出最大价格，将其减半后再放回队列。复杂度 $O(m\log n)$

---

<!--_header: B. 血魔训练 II -->

### 题意
* #### 给出 $n$ 个敌人，我方初始血量为 $x$ 。第 $i$ 个敌人会对我方造成 $a_i$ 伤害，击杀后我方恢复 $b_i$ 血量。

* #### 问能否在我方体力始终高于 $0$ 的情况下击杀所有敌人。

### 做法
* #### 将敌人分为两个部分：
#### 1. $b_i\ge a_i$ 的部分，不会降低我们的血线，我们首先考虑。将这部分敌人按照 $a_i$ 作为击杀门槛从小到大排序，然后一个一个击杀，应当能够全部击杀，否则一定无解。

#### 2. $b_i<a_i$ 的部分，这部分敌人会降低我们的血线。这部分敌人按照 $b_i$ 从大到小排序，按顺序击杀，如果能够全部击杀，则有解，否则无解。
---


<!--_header: B. 血魔训练 II -->

### 证明

* #### 第一部分先考虑是容易证明的，主要在于第二部分的排序方式。我们用邻项交换法证明。

* #### 假设能够击杀所有敌人，且存在相邻两项 $(i,j)$ 满足 $b_i<b_j$ ，不妨设在击杀敌人 $i$ 之前我方体力为 $x$，那么击杀 $i$ 后体力为 $x-a_i+b_i$ 这说明：$x>a_i$ 且 $x-a_i+b_i>a_j$。

* #### 那么，我们要证明交换后依然能够击杀掉 $(j,i)$ ，即证：$x>a_j$ 且 $x-a_j+b_j>a_i$ 。

    * #### 因为 $x-a_i+b_i>a_j \implies x-a_j>a_i-b_i>0$ 所以 $x>a_j$ 得证。
    * #### 因为$x-a_i+b_i>a_j \implies x-a_j+b_i>a_i$ 又因为 $b_i<b_j$ 所以 $x-a_j+b_j>x-a_j+b_i>a_i$ 得证。

证毕，因此第二部分按照 $b_i$ 从大到小排序即可。

---

<!--_header: C. 你美还是我美 -->

### 题意

* #### 给出 $a_1,a_2,\cdots a_n$ 和 $b_1,b_2,\cdots b_n$。求解

$$
\sum_{1\le i,j\le n} |a_i-b_j|
$$

### 做法

* #### 因为是绝对值，我们只需要对每个 $a_i$ 统计一下比他小的 $b_j$ 的个数 $x$ 和累加 $y$ 即可，然后可以容易的知道不小于 $a_i$ 的 $b_j$ 的个数 $n-x$ 以及累加 $B_{sum}-y$。这样，$a_i$ 对答案产生的贡献就是 $xa_i-y$ 加上 $B_{sum}-y-(n-x)a_i$ ，也就是 $2(xa_i-y)+B_{sum}-na_i$ 。

* #### 将 $a,b$ 数组一起排序，并保留每个元素是属于哪个数组的，然后从小到大扫描，把遇到的 $b$ 数组值累加，并计数，就可以维护 $x,y$ 了。复杂度在于排序， $O(n\log n)$

---

<!--_header: D. 逆序对 -->

### 题意
* #### 给出一个长度为 $n$ 的序列，问交换相邻两个数至多 $k$ 次之后，序列的逆序对数最少是多少。

### 做法
* #### 首先进行逆序对计数，可以使用归并排序计算逆序对数 $x$，复杂度 $O(n\log n)$。

* #### 然后答案是 $\max{\set{0,x-k}}$ 。这是因为，只要存在逆序对，就一定存在两个逆序对相邻，那么交换这两个数，逆序对数一定减少 $1$。

* 逆序对数论是 $O(n^2)$ 级别的，注意开 `long long`

---

<!--_header: E. 数独 -->
### 题意
* #### 求解 数独问题

### 做法
* #### 搜索加剪枝即可。

* #### 对每个 3×3 方格，维护一下哪些数字可用。对每行每列，也维护一下哪些数字可用。

* #### 深度优先搜索时，按顺序枚举当前未确定数字的方格，枚举当前方格的可用数字，然后继续深搜。递归前记得更新可用数字表，回溯时记得撤回更新。如果遇到一个格子无数可填，则直接剪枝回溯。搜到答案直接输出。

参考：[题解 P1784 【数独】](https://www.luogu.com.cn/blog/stonejuice/solution-p1784)

---

<!--_header: . 下一个 -->
### 题意

* #### 给出一个序列，求出比他大的下一个排列。如果它已经最大，则输出最小的排列（从小到大）。

### 做法：

* #### 对于一个从前往后单调递减的排列，是不存在调换元素使得它增大的。

* #### 因此，我们从后往前找，找到第一个 $a_i$ 满足 $a_i<a_{i+1}>a_{i+2}>a_{i+3}>\cdots a_{n}$

* #### 然后我们找到 $a_i$ 后面比它大的数中最小的一个，假设是 $a_j$，那么我们交换 $a_i$ 和 $a_j$ 之后，再把尾部的 $n-i$ 个数倒序排列即可。

* #### 找 $a_j$ 的过程扫描即可，倒序排列可以直接用 swap，复杂度都是线性的 $O(n)$ 。

* #### 也可以直接调库 $\texttt{next\_permutation} (a+1,a+n)$

---

<!--_header: . XRJ的钢琴键 -->

### 题意

* #### 给出 $a_1,a_2,\cdots a_n$ ，统计有多少个子区间的区间和是正数。

### 做法：
* #### 考虑前缀和数组 $s_0,s_1,\cdots s_n$ ，其中 $s_i = \sum_{j=1}^i a_j$ ，特别的 $s_0=0$ 。

* #### 那么对于一个 $1\le L\le R\le n$ 满足 $s_R>s_{L-1}$ ，那么 $[L,R]$ 就是正区间。

* #### 因此，我们只需要统计 $s$ 数组有多少个顺序对即可。采用从大到小的归并排序算法即可求出。


